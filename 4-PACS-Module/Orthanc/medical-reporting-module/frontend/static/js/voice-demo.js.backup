/**
 * SA Medical Voice Demo - Fixed Version
 * Optimized for South African medical terminology and workflows
 */

class SAVoiceDemo {
    constructor() {
        this.isRecording = false;
        this.isProcessing = false;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.visualizerBars = [];
        this.sessionId = null;
        this.transcriptionText = '';
        
        // Continuous recording properties
        this.audioChunks = [];
        this.isProcessing = false;
        this.recordingStartTime = null;
        
        // Network and error handling
        this.isOnline = navigator.onLine;
        this.offlineQueue = [];
        this.lastSuccessfulRequest = Date.now();
        
        // Training and shortcuts properties
        this.currentMode = 'dictation'; // 'dictation', 'training', 'shortcut_creation'
        this.trainingSession = null;
        this.currentTrainingTerm = null;
        this.userShortcuts = [];
        this.userId = 'demo_user';
        
        this.initializeElements();
        this.setupEventListeners();
        this.setupNetworkListeners();
        this.checkMicrophonePermissions();
        this.createAudioVisualizer();
        this.startVoiceSession();
        this.loadUserShortcuts();
    }
    
    initializeElements() {
        // Get elements with fallback
        this.micButton = document.getElementById('microphone-btn') || document.getElementById('microphoneButton');
        this.transcriptionArea = document.getElementById('transcription-area') || document.getElementById('transcriptionArea');
        this.audioVisualizer = document.getElementById('audio-visualizer') || document.getElementById('audioVisualizer');
        
        // Status indicators
        this.statusReady = document.getElementById('status-ready');
        this.statusListening = document.getElementById('status-listening');
        this.statusProcessing = document.getElementById('status-processing');
        this.statusError = document.getElementById('status-error');
        
        // Control buttons
        this.clearBtn = document.getElementById('clear-btn');
        this.copyBtn = document.getElementById('copy-btn');
        this.saveBtn = document.getElementById('save-btn');
    }
    
    setupEventListeners() {
        // Microphone button
        if (this.micButton) {
            this.micButton.addEventListener('click', () => this.toggleRecording());
        }
        
        // Control buttons
        if (this.clearBtn) {
            this.clearBtn.addEventListener('click', () => this.clearTranscription());
        }
        
        if (this.copyBtn) {
            this.copyBtn.addEventListener('click', () => this.copyTranscription());
        }
        
        if (this.saveBtn) {
            this.saveBtn.addEventListener('click', () => this.saveReport());
        }
        
        // Template buttons
        document.querySelectorAll('.template-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const template = e.currentTarget.dataset.template;
                this.loadTemplate(template);
            });
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.code === 'Space') {
                e.preventDefault();
                this.toggleRecording();
            }
        });
    }
    
    setupNetworkListeners() {
        window.addEventListener('online', () => {
            console.log('üåê Network connection restored');
            this.isOnline = true;
            this.processOfflineQueue();
        });
        
        window.addEventListener('offline', () => {
            console.log('üì° Network connection lost');
            this.isOnline = false;
        });
    }
    
    async checkMicrophonePermissions() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(track => track.stop());
            this.showStatus('ready', 'Microphone access granted');
            console.log('‚úÖ Microphone permissions granted');
        } catch (error) {
            console.error('‚ùå Microphone access denied:', error);
            this.showStatus('error', 'Microphone access required for voice dictation');
            this.showMicrophoneHelp();
        }
    }
    
    showMicrophoneHelp() {
        if (this.transcriptionArea) {
            this.transcriptionArea.innerHTML = `
                <div class="text-center text-red-600">
                    <i class="fas fa-microphone-slash text-4xl mb-4"></i>
                    <h3 class="text-lg font-semibold mb-2">Microphone Access Required</h3>
                    <p class="mb-4">Please allow microphone access to use voice dictation.</p>
                    <div class="mt-4 flex justify-center gap-2">
                        <button onclick="location.reload()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Refresh</button>
                    </div>
                </div>
            `;
        }
    }
    
    createAudioVisualizer() {
        if (!this.audioVisualizer) return;
        
        // Create visualizer bars
        this.audioVisualizer.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const bar = document.createElement('div');
            bar.className = 'audio-bar';
            bar.style.height = '10px';
            this.audioVisualizer.appendChild(bar);
            this.visualizerBars.push(bar);
        }
    }
    
    async startVoiceSession() {
        try {
            const response = await fetch('/api/voice/session/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    language: 'en-ZA',
                    medical_mode: true
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                this.sessionId = (data && (data.session && data.session.session_id)) || data.session_id || null;
                console.log('üé§ Voice session started:', this.sessionId || '(no id returned)');
            }
        } catch (error) {
            console.warn('Could not start voice session:', error);
        }
    }
    
    async toggleRecording() {
        if (this.isRecording) {
            await this.stopRecording();
        } else {
            await this.startRecording();
        }
    }
    
    async startRecording() {
        try {
            this.showStatus('listening', 'Listening...');
            this.isRecording = true;
            
            // Update button appearance
            if (this.micButton) {
                this.micButton.classList.add('recording');
                this.micButton.innerHTML = '<i class="fas fa-stop"></i>';
            }
            
            // Get microphone stream
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            // Setup MediaRecorder - prefer WAV if available, otherwise use WebM
            let mimeType = undefined;
            const preferredFormats = [
                'audio/wav',
                'audio/webm;codecs=opus',
                'audio/webm'
            ];
            
            for (const format of preferredFormats) {
                if (MediaRecorder.isTypeSupported(format)) {
                    mimeType = format;
                    break;
                }
            }
            
            console.log(`Using MediaRecorder with mimeType: ${mimeType || 'default'}`);
            
            this.mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});
            this.recordingMimeType = mimeType;
            this.audioChunks = [];
            this.recordingStartTime = Date.now();
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    console.log(`üì¶ Received audio chunk: ${event.data.size} bytes`);
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = () => {
                this.processCompleteRecording();
            };
            
            // Start recording - capture everything until stop is called
            console.log('Starting continuous recording...');
            this.mediaRecorder.start();
            
        } catch (error) {
            console.error('Recording error:', error);
            this.showStatus('error', 'Failed to start recording');
            this.isRecording = false;
        }
    }
    
    async stopRecording() {
        if (!this.isRecording) return;
        
        this.showStatus('processing', 'Processing audio...');
        this.isRecording = false;
        
        // Update button appearance
        if (this.micButton) {
            this.micButton.classList.remove('recording');
            this.micButton.classList.add('processing');
            this.micButton.innerHTML = '<i class="fas fa-cog fa-spin"></i>';
        }
        
        // Stop recording
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
        
        // Stop microphone stream
        if (this.mediaRecorder && this.mediaRecorder.stream) {
            this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }
    
    async processCompleteRecording() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        
        try {
            console.log(`üéµ Processing complete recording: ${this.audioChunks.length} chunks`);
            
            // Combine all audio chunks into one blob
            const completeAudioBlob = new Blob(this.audioChunks, { 
                type: this.recordingMimeType || 'audio/webm' 
            });
            
            console.log(`üì¶ Complete audio: ${completeAudioBlob.size} bytes`);
            
            // Convert to WAV if needed
            let audioBlob = completeAudioBlob;
            if (!completeAudioBlob.type.includes('wav')) {
                try {
                    console.log('üîÑ Converting to WAV...');
                    audioBlob = await this.convertToWAV(completeAudioBlob);
                    console.log(`‚úÖ Converted to WAV: ${audioBlob.size} bytes`);
                } catch (convError) {
                    console.error('‚ùå Audio conversion failed:', convError);
                    audioBlob = completeAudioBlob; // Use original if conversion fails
                }
            }
            
            // Send to server for transcription
            await this.transcribeCompleteAudio(audioBlob);
            
        } catch (error) {
            console.error('‚ùå Recording processing failed:', error);
            this.showStatus('error', 'Processing failed');
        } finally {
            this.isProcessing = false;
            this.finalizeTranscription();
        }
    }
    
    async transcribeCompleteAudio(audioBlob) {
        try {
            console.log(`üéµ Transcribing complete audio: ${audioBlob.size} bytes`);
            
            // First check for voice shortcuts if in dictation mode
            if (this.currentMode === 'dictation') {
                const shortcutTriggered = await this.checkForVoiceShortcuts(audioBlob);
                if (shortcutTriggered) {
                    return; // Shortcut was executed, don't proceed with transcription
                }
            }
            
            // Create form data
            const formData = new FormData();
            formData.append('audio', audioBlob, 'complete_recording.wav');
            formData.append('session_id', this.sessionId || 'demo');
            formData.append('language', 'en-ZA');
            formData.append('user_id', this.userId); // Add user ID for enhanced processing
            
            // Send to server using the regular transcribe endpoint
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            try {
                const response = await fetch('/api/voice/transcribe', {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úÖ Transcription result:', result);
                    
                    if (result.success && result.transcription) {
                        this.displayTranscription(result.transcription);
                        this.showStatus('ready', 'Transcription complete');
                    } else {
                        console.warn('‚ùå Transcription failed:', result.error || 'No transcription returned');
                        this.showStatus('error', result.error || 'Transcription failed');
                    }
                } else {
                    const errorText = await response.text();
                    throw new Error(`API failed with status ${response.status}: ${errorText}`);
                }
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - server may be overloaded');
                } else {
                    throw fetchError;
                }
            }
            
        } catch (error) {
            console.error('‚ùå Complete audio transcription failed:', error);
            this.showStatus('error', 'Transcription failed: ' + error.message);
        }
    }
    
    async convertToWAV(audioBlob) {
        // Convert any audio blob to WAV blob using Web Audio API
        return new Promise((resolve, reject) => {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000  // Set to 16kHz for Whisper
                });
                const fileReader = new FileReader();
                
                fileReader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        // Resample to 16kHz if needed
                        let processedBuffer = audioBuffer;
                        if (audioBuffer.sampleRate !== 16000) {
                            processedBuffer = await this.resampleAudioBuffer(audioBuffer, 16000);
                        }
                        
                        const wavBlob = this.audioBufferToWAV(processedBuffer);
                        resolve(wavBlob);
                    } catch (decodeError) {
                        console.error('Audio decode error:', decodeError);
                        reject(new Error(`Audio decode failed: ${decodeError.message}`));
                    }
                };
                
                fileReader.onerror = () => {
                    reject(new Error('Failed to read audio blob'));
                };
                
                fileReader.readAsArrayBuffer(audioBlob);
                
            } catch (error) {
                reject(new Error(`Audio conversion setup failed: ${error.message}`));
            }
        });
    }
    
    async resampleAudioBuffer(audioBuffer, targetSampleRate) {
        // Simple resampling using Web Audio API
        const offlineContext = new OfflineAudioContext(
            1, // mono
            Math.ceil(audioBuffer.duration * targetSampleRate),
            targetSampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(offlineContext.destination);
        source.start();
        
        return await offlineContext.startRendering();
    }
    
    audioBufferToWAV(audioBuffer) {
        // Convert AudioBuffer to WAV blob - force mono 16kHz
        const numberOfChannels = 1; // Force mono
        const sampleRate = 16000;   // Force 16kHz
        const length = audioBuffer.length;
        const bitsPerSample = 16;
        const bytesPerSample = bitsPerSample / 8;
        const blockAlign = numberOfChannels * bytesPerSample;
        const byteRate = sampleRate * blockAlign;
        const dataSize = length * blockAlign;
        const bufferSize = 44 + dataSize;
        
        const arrayBuffer = new ArrayBuffer(bufferSize);
        const view = new DataView(arrayBuffer);
        
        // WAV header
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, bufferSize - 8, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitsPerSample, true);
        writeString(36, 'data');
        view.setUint32(40, dataSize, true);
        
        // Convert audio data to mono
        let offset = 44;
        const channelData = audioBuffer.getChannelData(0); // Use first channel
        
        // If stereo, mix down to mono
        if (audioBuffer.numberOfChannels > 1) {
            const rightChannel = audioBuffer.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const sample = (channelData[i] + rightChannel[i]) / 2;
                const clampedSample = Math.max(-1, Math.min(1, sample));
                view.setInt16(offset, clampedSample * 0x7FFF, true);
                offset += 2;
            }
        } else {
            for (let i = 0; i < length; i++) {
                const clampedSample = Math.max(-1, Math.min(1, channelData[i]));
                view.setInt16(offset, clampedSample * 0x7FFF, true);
                offset += 2;
            }
        }
        
        return new Blob([arrayBuffer], { type: 'audio/wav' });
    }
    
    displayTranscription(text) {
        if (!text) return;
        
        console.log(`üìù Displaying transcription: "${text}"`);
        
        this.transcriptionText = text;
        
        // Update the transcription area
        const transcriptionArea = document.getElementById('transcription-area');
        if (transcriptionArea) {
            transcriptionArea.innerHTML = `<div class="text-gray-800 whitespace-pre-wrap">${text}</div>`;
            transcriptionArea.classList.add('active');
            transcriptionArea.scrollTop = transcriptionArea.scrollHeight;
        }
        
        // Also update textarea if it exists (for compatibility)
        const textarea = document.getElementById('report-text');
        if (textarea) {
            textarea.value = text;
            textarea.scrollTop = textarea.scrollHeight;
        }
    }
    

    
    finalizeTranscription() {
        console.log('üèÅ Finalizing transcription...');
        
        if (this.micButton) {
            this.micButton.classList.remove('recording', 'processing');
            this.micButton.innerHTML = '<i class="fas fa-microphone"></i>';
        }
        
        if (!this.transcriptionText) {
            this.showStatus('ready', 'Ready to record');
        } else {
            this.showStatus('ready', 'Recording complete');
        }
        
        if (this.sessionId) {
            fetch(`/api/voice/session/${this.sessionId}/finalize`, {
                method: 'POST'
            }).then(response => {
                if (response.ok) {
                    console.log('‚úÖ Session finalized');
                }
            }).catch(error => {
                console.warn('Session finalization failed:', error);
            });
        }
    }
    
    showStatus(type, message) {
        console.log(`Status: ${type} - ${message}`);
        
        // Hide all status indicators
        const statuses = ['ready', 'listening', 'processing', 'error'];
        statuses.forEach(status => {
            const element = document.getElementById(`status-${status}`);
            if (element) {
                element.style.display = 'none';
                element.classList.add('hidden');
            }
        });
        
        // Show current status
        const currentStatus = document.getElementById(`status-${type}`);
        if (currentStatus) {
            currentStatus.style.display = 'inline-flex';
            currentStatus.classList.remove('hidden');
            
            // Update the message while preserving the icon
            const icon = currentStatus.querySelector('i');
            if (icon) {
                currentStatus.innerHTML = icon.outerHTML + ' ' + message;
            } else {
                currentStatus.textContent = message;
            }
        }
    }
    
    clearTranscription() {
        this.transcriptionText = '';
        
        // Clear the transcription area
        const transcriptionArea = document.getElementById('transcription-area');
        if (transcriptionArea) {
            transcriptionArea.innerHTML = `
                <div class="text-gray-500 text-center">
                    <i class="fas fa-microphone-alt text-3xl mb-3"></i>
                    <p>Your voice transcription will appear here...</p>
                    <p class="text-sm mt-2">Speak clearly for best results with SA English medical terms</p>
                </div>
            `;
            transcriptionArea.classList.remove('active');
        }
        
        // Also clear textarea if it exists
        const textarea = document.getElementById('report-text');
        if (textarea) {
            textarea.value = '';
        }
        
        console.log('üóëÔ∏è Transcription cleared');
    }
    
    copyTranscription() {
        if (this.transcriptionText) {
            navigator.clipboard.writeText(this.transcriptionText).then(() => {
                console.log('üìã Transcription copied to clipboard');
                // Show feedback
                const copyBtn = document.getElementById('copy-btn');
                if (copyBtn) {
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                    }, 2000);
                }
            });
        }
    }
    
    saveReport() {
        if (this.transcriptionText) {
            const blob = new Blob([this.transcriptionText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `medical-report-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            console.log('üíæ Report saved');
            
            // Show feedback
            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                const originalText = saveBtn.innerHTML;
                saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
                setTimeout(() => {
                    saveBtn.innerHTML = originalText;
                }, 2000);
            }
        }
    }
    
    loadTemplate(templateType) {
        // Basic template loading
        const templates = {
            consultation: 'Chief Complaint:\n\nHistory of Present Illness:\n\nPhysical Examination:\n\nAssessment and Plan:\n',
            followup: 'Follow-up Visit:\n\nInterval History:\n\nCurrent Medications:\n\nPhysical Examination:\n\nAssessment and Plan:\n',
            discharge: 'Discharge Summary:\n\nAdmission Date:\nDischarge Date:\n\nDiagnoses:\n\nHospital Course:\n\nDischarge Medications:\n\nFollow-up Instructions:\n'
        };
        
        const template = templates[templateType] || '';
        this.transcriptionText = template;
        
        // Update the transcription area
        const transcriptionArea = document.getElementById('transcription-area');
        if (transcriptionArea) {
            transcriptionArea.innerHTML = `<div class="text-gray-800 whitespace-pre-line">${template}</div>`;
            transcriptionArea.classList.add('active');
        }
        
        // Also update textarea if it exists
        const textarea = document.getElementById('report-text');
        if (textarea) {
            textarea.value = template;
        }
        
        console.log(`üìã ${templateType} template loaded`);
    }

    // Training and shortcuts methods
    async recordTrainingAudio() {
        if (this.isRecording) {
            await this.stopTrainingRecording();
        } else {
            await this.startTrainingRecording();
        }
    }
    
    async startTrainingRecording() {
        try {
            this.isRecording = true;
            const recordBtn = document.getElementById('training-record-btn');
            if (recordBtn) {
                recordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Recording';
                recordBtn.classList.add('recording');
            }
            
            // Get microphone stream
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            this.audioChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = () => {
                this.processTrainingAudio();
            };
            
            this.mediaRecorder.start();
            this.showStatus('listening', 'Recording training audio...');
            
        } catch (error) {
            console.error('Training recording error:', error);
            this.showStatus('error', 'Failed to start training recording');
            this.isRecording = false;
        }
    }
    
    async stopTrainingRecording() {
        if (!this.isRecording) return;
        
        this.isRecording = false;
        this.showStatus('processing', 'Processing training audio...');
        
        const recordBtn = document.getElementById('training-record-btn');
        if (recordBtn) {
            recordBtn.innerHTML = '<i class="fas fa-cog fa-spin mr-2"></i>Processing...';
            recordBtn.classList.remove('recording');
        }
        
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
        
        if (this.mediaRecorder && this.mediaRecorder.stream) {
            this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }
    
    async processTrainingAudio() {
        try {
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            
            // Convert to WAV if needed
            let processedAudio = audioBlob;
            try {
                processedAudio = await this.convertToWAV(audioBlob);
            } catch (convError) {
                console.warn('Audio conversion failed, using original:', convError);
            }
            
            // Send to training API
            const formData = new FormData();
            formData.append('audio', processedAudio, 'training_audio.wav');
            formData.append('user_id', this.userId);
            formData.append('medical_term', this.currentTrainingTerm);
            formData.append('session_id', this.trainingSession?.id || 'demo');
            
            const response = await fetch('/api/voice/training/process', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    this.showTrainingResult(result);
                    this.showStatus('ready', 'Training audio processed');
                } else {
                    this.showStatus('error', result.error || 'Training failed');
                }
            } else {
                throw new Error('Training API request failed');
            }
            
        } catch (error) {
            console.error('Training audio processing failed:', error);
            this.showStatus('error', 'Training processing failed');
        } finally {
            const recordBtn = document.getElementById('training-record-btn');
            if (recordBtn) {
                recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Record';
                recordBtn.classList.remove('recording');
            }
        }
    }
    
    showTrainingResult(result) {
        const resultDiv = document.getElementById('training-result');
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div class="mt-4 p-4 rounded-lg ${result.accuracy_score > 0.8 ? 'bg-green-100' : 'bg-yellow-100'}">
                    <h4 class="font-semibold">Training Result</h4>
                    <p>Expected: "${result.expected_text}"</p>
                    <p>Recognized: "${result.actual_text}"</p>
                    <p>Accuracy: ${(result.accuracy_score * 100).toFixed(1)}%</p>
                    ${result.accuracy_score < 0.8 ? '<p class="text-sm text-yellow-700 mt-2">Try speaking more clearly or closer to the microphone.</p>' : ''}
                </div>
            `;
        }
    }
    
    // Voice Shortcuts Management Methods
    async loadUserShortcuts() {
        try {
            const response = await fetch(`/api/voice/shortcuts/list?user_id=${this.userId}`);
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    this.userShortcuts = data.shortcuts || [];
                    this.displayShortcutsList();
                }
            }
        } catch (error) {
            console.error('Failed to load user shortcuts:', error);
        }
    }
    
    displayShortcutsList() {
        const shortcutsList = document.getElementById('shortcuts-list');
        if (!shortcutsList) return;
        
        if (this.userShortcuts.length === 0) {
            shortcutsList.innerHTML = `
                <div class="text-center py-8 text-gray-500">
                    <i class="fas fa-bolt text-4xl mb-4"></i>
                    <h3 class="text-lg font-semibold mb-2">No Voice Shortcuts Yet</h3>
                    <p class="mb-4">Create your first voice shortcut to quickly access templates</p>
                    <button onclick="voiceDemo.showCreateShortcutInterface()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
                        <i class="fas fa-plus mr-2"></i>Create First Shortcut
                    </button>
                </div>
            `;
            return;
        }
        
        const shortcutsHTML = this.userShortcuts.map(shortcut => `
            <div class="border rounded-lg p-4 bg-gray-50">
                <div class="flex justify-between items-start">
                    <div class="flex-1">
                        <h4 class="font-semibold text-lg">${shortcut.name}</h4>
                        <p class="text-gray-600 text-sm mb-2">Template: ${shortcut.template_id || 'Custom Content'}</p>
                        <div class="flex items-center text-sm text-gray-500 space-x-4">
                            <span><i class="fas fa-calendar mr-1"></i>Created: ${new Date(shortcut.created_date).toLocaleDateString()}</span>
                            <span><i class="fas fa-chart-line mr-1"></i>Used: ${shortcut.usage_count || 0} times</span>
                            <span><i class="fas fa-percentage mr-1"></i>Accuracy: ${((shortcut.accuracy_score || 0) * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="voiceDemo.testShortcut(${shortcut.id})" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors">
                            <i class="fas fa-play mr-1"></i>Test
                        </button>
                        <button onclick="voiceDemo.editShortcut(${shortcut.id})" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition-colors">
                            <i class="fas fa-edit mr-1"></i>Edit
                        </button>
                        <button onclick="voiceDemo.deleteShortcut(${shortcut.id})" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm transition-colors">
                            <i class="fas fa-trash mr-1"></i>Delete
                        </button>
                    </div>
                </div>
                ${shortcut.template_content ? `
                    <div class="mt-3 p-3 bg-white rounded border">
                        <p class="text-sm font-medium text-gray-700 mb-1">Template Preview:</p>
                        <p class="text-sm text-gray-600 truncate">${shortcut.template_content.substring(0, 100)}${shortcut.template_content.length > 100 ? '...' : ''}</p>
                    </div>
                ` : ''}
            </div>
        `).join('');
        
        shortcutsList.innerHTML = shortcutsHTML;
    }
    
    showCreateShortcutInterface() {
        const shortcutsList = document.getElementById('shortcuts-list');
        if (!shortcutsList) return;
        
        shortcutsList.innerHTML = `
            <div class="bg-white border-2 border-blue-200 rounded-lg p-6">
                <h3 class="text-xl font-semibold mb-4">Create New Voice Shortcut</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Shortcut Name</label>
                        <input type="text" id="shortcut-name" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., 'Chest X-ray Report'">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Voice Command</label>
                        <div class="flex items-center space-x-3">
                            <button id="record-shortcut-btn" onclick="voiceDemo.recordShortcutAudio()" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-colors">
                                <i class="fas fa-microphone mr-2"></i>Record Command
                            </button>
                            <span id="recording-status" class="text-sm text-gray-500">Click to record your voice command</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Say a short phrase like "chest x-ray" or "start consultation"</p>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Template Association</label>
                        <select id="template-select" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Select a template...</option>
                            <option value="chest-xray">Chest X-ray Report</option>
                            <option value="consultation">Consultation Note</option>
                            <option value="discharge">Discharge Summary</option>
                            <option value="referral">Referral Letter</option>
                            <option value="custom">Custom Content</option>
                        </select>
                    </div>
                    
                    <div id="custom-content-section" class="hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Custom Template Content</label>
                        <textarea id="custom-content" rows="4" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your custom template content..."></textarea>
                    </div>
                    
                    <div class="flex space-x-3 pt-4">
                        <button onclick="voiceDemo.saveShortcut()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
                            <i class="fas fa-save mr-2"></i>Save Shortcut
                        </button>
                        <button onclick="voiceDemo.cancelShortcutCreation()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded transition-colors">
                            <i class="fas fa-times mr-2"></i>Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Setup template select change handler
        const templateSelect = document.getElementById('template-select');
        const customSection = document.getElementById('custom-content-section');
        
        templateSelect.addEventListener('change', function() {
            if (this.value === 'custom') {
                customSection.classList.remove('hidden');
            } else {
                customSection.classList.add('hidden');
            }
        });
    }
    
    async recordShortcutAudio() {
        const recordBtn = document.getElementById('record-shortcut-btn');
        const statusSpan = document.getElementById('recording-status');
        
        if (this.isRecording) {
            // Stop recording
            this.isRecording = false;
            recordBtn.innerHTML = '<i class="fas fa-cog fa-spin mr-2"></i>Processing...';
            statusSpan.textContent = 'Processing audio...';
            
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            
            if (this.mediaRecorder && this.mediaRecorder.stream) {
                this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        } else {
            // Start recording
            try {
                this.isRecording = true;
                recordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Recording';
                recordBtn.classList.add('recording');
                statusSpan.textContent = 'Recording... speak your command now';
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                this.audioChunks = [];
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    }
                };
                
                this.mediaRecorder.onstop = () => {
                    this.processShortcutAudio();
                };
                
                this.mediaRecorder.start();
                
            } catch (error) {
                console.error('Shortcut recording error:', error);
                statusSpan.textContent = 'Recording failed - please try again';
                this.isRecording = false;
                recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Record Command';
                recordBtn.classList.remove('recording');
            }
        }
    }
    
    async processShortcutAudio() {
        const recordBtn = document.getElementById('record-shortcut-btn');
        const statusSpan = document.getElementById('recording-status');
        
        try {
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            
            // Convert to WAV if needed
            let processedAudio = audioBlob;
            try {
                processedAudio = await this.convertToWAV(audioBlob);
            } catch (convError) {
                console.warn('Audio conversion failed, using original:', convError);
            }
            
            // Store the audio for later use
            this.shortcutAudioBlob = processedAudio;
            
            recordBtn.innerHTML = '<i class="fas fa-check mr-2"></i>Recorded';
            recordBtn.classList.remove('recording');
            recordBtn.classList.add('bg-green-600');
            statusSpan.textContent = 'Voice command recorded successfully!';
            
        } catch (error) {
            console.error('Shortcut audio processing failed:', error);
            recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Record Command';
            recordBtn.classList.remove('recording');
            statusSpan.textContent = 'Processing failed - please try again';
        }
    }
    
    async saveShortcut() {
        const shortcutName = document.getElementById('shortcut-name').value.trim();
        const templateSelect = document.getElementById('template-select').value;
        const customContent = document.getElementById('custom-content').value.trim();
        
        if (!shortcutName) {
            alert('Please enter a shortcut name');
            return;
        }
        
        if (!this.shortcutAudioBlob) {
            alert('Please record a voice command first');
            return;
        }
        
        if (!templateSelect) {
            alert('Please select a template or choose custom content');
            return;
        }
        
        if (templateSelect === 'custom' && !customContent) {
            alert('Please enter custom template content');
            return;
        }
        
        try {
            const formData = new FormData();
            formData.append('audio', this.shortcutAudioBlob, 'shortcut_audio.wav');
            formData.append('user_id', this.userId);
            formData.append('shortcut_name', shortcutName);
            formData.append('template_id', templateSelect === 'custom' ? null : templateSelect);
            formData.append('template_content', templateSelect === 'custom' ? customContent : '');
            
            const response = await fetch('/api/voice/shortcuts/create', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    // Refresh shortcuts list
                    await this.loadUserShortcuts();
                    this.showStatus('ready', 'Voice shortcut created successfully');
                } else {
                    alert('Failed to create shortcut: ' + (result.error || 'Unknown error'));
                }
            } else {
                throw new Error('Shortcut creation API request failed');
            }
            
        } catch (error) {
            console.error('Shortcut creation failed:', error);
            alert('Failed to create shortcut. Please try again.');
        }
    }
    
    cancelShortcutCreation() {
        this.shortcutAudioBlob = null;
        this.displayShortcutsList();
    }
    
    async testShortcut(shortcutId) {
        const shortcut = this.userShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        
        // Show test interface
        const shortcutsList = document.getElementById('shortcuts-list');
        if (!shortcutsList) return;
        
        const testHTML = `
            <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-6 mb-4">
                <h3 class="text-xl font-semibold mb-4">Test Voice Shortcut: "${shortcut.shortcut_name}"</h3>
                <p class="text-gray-600 mb-4">Say your voice command to test if it matches this shortcut</p>
                
                <div class="flex items-center space-x-3 mb-4">
                    <button id="test-record-btn" onclick="voiceDemo.recordTestAudio(${shortcutId})" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded transition-colors">
                        <i class="fas fa-microphone mr-2"></i>Start Test
                    </button>
                    <span id="test-status" class="text-sm text-gray-500">Click to start testing</span>
                </div>
                
                <div id="test-result" class="hidden mt-4"></div>
                
                <div class="flex space-x-3 pt-4">
                    <button onclick="voiceDemo.displayShortcutsList()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded transition-colors">
                        <i class="fas fa-arrow-left mr-2"></i>Back to List
                    </button>
                </div>
            </div>
        `;
        
        shortcutsList.innerHTML = testHTML + shortcutsList.innerHTML;
    }
    
    async recordTestAudio(shortcutId) {
        const recordBtn = document.getElementById('test-record-btn');
        const statusSpan = document.getElementById('test-status');
        
        if (this.isRecording) {
            // Stop recording
            this.isRecording = false;
            recordBtn.innerHTML = '<i class="fas fa-cog fa-spin mr-2"></i>Testing...';
            statusSpan.textContent = 'Processing and matching...';
            
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            
            if (this.mediaRecorder && this.mediaRecorder.stream) {
                this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        } else {
            // Start recording
            try {
                this.isRecording = true;
                this.testingShortcutId = shortcutId;
                recordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Test';
                recordBtn.classList.add('recording');
                statusSpan.textContent = 'Recording... say your command';
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                this.audioChunks = [];
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    }
                };
                
                this.mediaRecorder.onstop = () => {
                    this.processTestAudio();
                };
                
                this.mediaRecorder.start();
                
            } catch (error) {
                console.error('Test recording error:', error);
                statusSpan.textContent = 'Recording failed - please try again';
                this.isRecording = false;
                recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Start Test';
                recordBtn.classList.remove('recording');
            }
        }
    }
    
    async processTestAudio() {
        const recordBtn = document.getElementById('test-record-btn');
        const statusSpan = document.getElementById('test-status');
        const resultDiv = document.getElementById('test-result');
        
        try {
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            
            // Convert to WAV if needed
            let processedAudio = audioBlob;
            try {
                processedAudio = await this.convertToWAV(audioBlob);
            } catch (convError) {
                console.warn('Audio conversion failed, using original:', convError);
            }
            
            // Test against all shortcuts (the match endpoint will return the best match)
            const formData = new FormData();
            formData.append('audio', processedAudio, 'test_audio.wav');
            formData.append('user_id', this.userId);
            formData.append('confidence_threshold', '0.5'); // Lower threshold for testing
            
            const response = await fetch('/api/voice/shortcuts/match', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                
                recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Start Test';
                recordBtn.classList.remove('recording');
                statusSpan.textContent = 'Test complete';
                
                if (resultDiv) {
                    resultDiv.classList.remove('hidden');
                    
                    // Check if the matched shortcut is the one we're testing
                    const matchedShortcut = result.matched_shortcut;
                    const testingShortcut = this.userShortcuts.find(s => s.id === this.testingShortcutId);
                    const isCorrectMatch = matchedShortcut && matchedShortcut.id === this.testingShortcutId;
                    const confidence = result.confidence || 0;
                    
                    let statusClass, statusIcon, statusText, detailText;
                    
                    if (isCorrectMatch) {
                        statusClass = 'bg-green-100 border-green-200';
                        statusIcon = '‚úÖ Correct Match';
                        statusText = 'text-green-800';
                        detailText = `<p class="text-sm text-green-700 mt-1">Perfect! Your voice command correctly triggers "${testingShortcut.name}"</p>`;
                    } else if (matchedShortcut) {
                        statusClass = 'bg-yellow-100 border-yellow-200';
                        statusIcon = '‚ö†Ô∏è Different Match';
                        statusText = 'text-yellow-800';
                        detailText = `<p class="text-sm text-yellow-700 mt-1">Your command triggered "${matchedShortcut.name}" instead. Try speaking more distinctly.</p>`;
                    } else {
                        statusClass = 'bg-red-100 border-red-200';
                        statusIcon = '‚ùå No Match';
                        statusText = 'text-red-800';
                        detailText = '<p class="text-sm text-red-700 mt-1">No shortcuts matched. Try speaking more clearly or re-record the shortcut.</p>';
                    }
                    
                    resultDiv.innerHTML = `
                        <div class="p-4 rounded-lg ${statusClass} border">
                            <h4 class="font-semibold ${statusText}">
                                ${statusIcon}
                            </h4>
                            <p class="text-sm mt-2">Confidence Score: ${(confidence * 100).toFixed(1)}%</p>
                            ${detailText}
                        </div>
                    `;
                }
            } else {
                throw new Error('Test API request failed');
            }
            
        } catch (error) {
            console.error('Test audio processing failed:', error);
            recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Start Test';
            recordBtn.classList.remove('recording');
            statusSpan.textContent = 'Test failed - please try again';
        }
    }
    
    async editShortcut(shortcutId) {
        const shortcut = this.userShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        
        // Show edit interface (similar to create but pre-filled)
        const shortcutsList = document.getElementById('shortcuts-list');
        if (!shortcutsList) return;
        
        shortcutsList.innerHTML = `
            <div class="bg-white border-2 border-blue-200 rounded-lg p-6">
                <h3 class="text-xl font-semibold mb-4">Edit Voice Shortcut</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Shortcut Name</label>
                        <input type="text" id="edit-shortcut-name" value="${shortcut.name}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Template Association</label>
                        <select id="edit-template-select" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Select a template...</option>
                            <option value="chest-xray" ${shortcut.template_id === 'chest-xray' ? 'selected' : ''}>Chest X-ray Report</option>
                            <option value="consultation" ${shortcut.template_id === 'consultation' ? 'selected' : ''}>Consultation Note</option>
                            <option value="discharge" ${shortcut.template_id === 'discharge' ? 'selected' : ''}>Discharge Summary</option>
                            <option value="referral" ${shortcut.template_id === 'referral' ? 'selected' : ''}>Referral Letter</option>
                            <option value="custom" ${!shortcut.template_id ? 'selected' : ''}>Custom Content</option>
                        </select>
                    </div>
                    
                    <div id="edit-custom-content-section" class="${!shortcut.template_id ? '' : 'hidden'}">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Custom Template Content</label>
                        <textarea id="edit-custom-content" rows="4" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">${shortcut.template_content || ''}</textarea>
                    </div>
                    
                    <div class="flex space-x-3 pt-4">
                        <button onclick="voiceDemo.updateShortcut(${shortcut.id})" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
                            <i class="fas fa-save mr-2"></i>Update Shortcut
                        </button>
                        <button onclick="voiceDemo.displayShortcutsList()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded transition-colors">
                            <i class="fas fa-times mr-2"></i>Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Setup template select change handler
        const templateSelect = document.getElementById('edit-template-select');
        const customSection = document.getElementById('edit-custom-content-section');
        
        templateSelect.addEventListener('change', function() {
            if (this.value === 'custom') {
                customSection.classList.remove('hidden');
            } else {
                customSection.classList.add('hidden');
            }
        });
    }
    
    async updateShortcut(shortcutId) {
        const shortcutName = document.getElementById('edit-shortcut-name').value.trim();
        const templateSelect = document.getElementById('edit-template-select').value;
        const customContent = document.getElementById('edit-custom-content').value.trim();
        
        if (!shortcutName) {
            alert('Please enter a shortcut name');
            return;
        }
        
        if (!templateSelect) {
            alert('Please select a template or choose custom content');
            return;
        }
        
        if (templateSelect === 'custom' && !customContent) {
            alert('Please enter custom template content');
            return;
        }
        
        try {
            const response = await fetch(`/api/voice/shortcuts/${shortcutId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    user_id: this.userId,
                    shortcut_name: shortcutName,
                    template_id: templateSelect === 'custom' ? null : templateSelect,
                    template_content: templateSelect === 'custom' ? customContent : ''
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    await this.loadUserShortcuts();
                    this.showStatus('ready', 'Voice shortcut updated successfully');
                } else {
                    alert('Failed to update shortcut: ' + (result.error || 'Unknown error'));
                }
            } else {
                throw new Error('Shortcut update API request failed');
            }
            
        } catch (error) {
            console.error('Shortcut update failed:', error);
            alert('Failed to update shortcut. Please try again.');
        }
    }
    
    async deleteShortcut(shortcutId) {
        const shortcut = this.userShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        
        if (!confirm(`Are you sure you want to delete the shortcut "${shortcut.name}"?`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/voice/shortcuts/${shortcutId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    user_id: this.userId
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    await this.loadUserShortcuts();
                    this.showStatus('ready', 'Voice shortcut deleted successfully');
                } else {
                    alert('Failed to delete shortcut: ' + (result.error || 'Unknown error'));
                }
            } else {
                throw new Error('Shortcut deletion API request failed');
            }
            
        } catch (error) {
            console.error('Shortcut deletion failed:', error);
            alert('Failed to delete shortcut. Please try again.');
        }
    }
    
    async checkForVoiceShortcuts(audioBlob) {
        if (this.userShortcuts.length === 0) {
            return false; // No shortcuts to check
        }
        
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'shortcut_check.wav');
            formData.append('user_id', this.userId);
            formData.append('confidence_threshold', '0.7'); // Higher threshold for actual use
            
            const response = await fetch('/api/voice/shortcuts/match', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.success && result.matched_shortcut) {
                    const shortcut = result.matched_shortcut;
                    console.log(`üéØ Voice shortcut triggered: ${shortcut.name}`);
                    
                    // Execute the shortcut
                    await this.executeVoiceShortcut(shortcut);
                    return true; // Shortcut was executed
                }
            }
        } catch (error) {
            console.error('Voice shortcut check failed:', error);
        }
        
        return false; // No shortcut matched or error occurred
    }
    
    async executeVoiceShortcut(shortcut) {
        console.log(`üöÄ Executing voice shortcut: ${shortcut.name}`);
        
        // Load the template content
        let templateContent = '';
        
        if (shortcut.template_id) {
            // Load predefined template
            const templates = {
                'chest-xray': 'CHEST X-RAY REPORT\n\nClinical History:\n\nFindings:\n\nImpression:\n\nRecommendations:\n',
                'consultation': 'CONSULTATION NOTE\n\nChief Complaint:\n\nHistory of Present Illness:\n\nPhysical Examination:\n\nAssessment and Plan:\n',
                'discharge': 'DISCHARGE SUMMARY\n\nAdmission Date:\nDischarge Date:\n\nDiagnoses:\n\nHospital Course:\n\nDischarge Medications:\n\nFollow-up Instructions:\n',
                'referral': 'REFERRAL LETTER\n\nTo:\nFrom:\nDate:\n\nRe: Patient Name\n\nDear Colleague,\n\nI am referring the above patient for:\n\nClinical Summary:\n\nThank you for your assistance.\n\nSincerely,\n'
            };
            templateContent = templates[shortcut.template_id] || '';
        } else {
            // Use custom content
            templateContent = shortcut.template_content || '';
        }
        
        // Display the template content
        this.displayTranscription(templateContent);
        
        // Show success message
        this.showStatus('ready', `Voice shortcut "${shortcut.name}" executed`);
        
        // Update usage statistics
        try {
            await fetch(`/api/voice/shortcuts/${shortcut.id}/usage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    user_id: this.userId
                })
            });
        } catch (error) {
            console.warn('Failed to update shortcut usage stats:', error);
        }
    }
}
                'consultation': 'CONSULTATION NOTE\n\nDate: [Date]\nPatient: [Patient Name]\n\nCHIEF COMPLAINT:\n\nHISTORY OF PRESENT ILLNESS:\n\nPHYSICAL EXAMINATION:\n- Vital signs:\n- General appearance:\n- Systems review:\n\nASSESSMENT AND PLAN:\n\nDr. [Name]',
                'discharge': 'DISCHARGE SUMMARY\n\nPatient: [Patient Name]\nAdmission Date: [Date]\nDischarge Date: [Date]\n\nDIAGNOSES:\n1. Primary:\n2. Secondary:\n\nHOSPITAL COURSE:\n\nDISCHARGE MEDICATIONS:\n\nFOLLOW-UP INSTRUCTIONS:\n\nDr. [Name]',
                'referral': 'REFERRAL LETTER\n\nDate: [Date]\nTo: [Specialist/Department]\nRe: [Patient Name]\n\nDear Colleague,\n\nI am referring the above patient for your expert opinion and management.\n\nHISTORY:\n\nEXAMINATION FINDINGS:\n\nREASON FOR REFERRAL:\n\nThank you for your assistance.\n\nYours sincerely,\nDr. [Name]'
            };
            
            templateContent = templates[shortcut.template_id] || shortcut.template_content || '';
        } else {
            templateContent = shortcut.template_content || '';
        }
        
        // Display the template
        this.displayTranscription(templateContent);
        
        // Show feedback that shortcut was triggered
        this.showStatus('ready', `Voice shortcut "${shortcut.name}" activated`);
        
        // Update shortcut usage statistics
        this.updateShortcutUsage(shortcut.id);
    }
    
    async updateShortcutUsage(shortcutId, confidence = 0.9) {
        try {
            // The usage tracking is handled automatically by the voice matcher
            // when shortcuts are matched, so this is just a placeholder
            console.log(`Shortcut ${shortcutId} used with confidence ${confidence}`);
        } catch (error) {
            console.error('Failed to update shortcut usage:', error);
        }
    }
    
    // Training methods
    async loadTrainingCategories() {
        try {
            const response = await fetch('/api/voice/training/categories');
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    this.displayTrainingCategories(data.categories);
                }
            }
        } catch (error) {
            console.error('Failed to load training categories:', error);
        }
    }
    
    displayTrainingCategories(categories) {
        const categoriesDiv = document.getElementById('training-categories');
        if (!categoriesDiv) return;
        
        const categoriesHTML = Object.entries(categories).map(([category, terms]) => `
            <div class="bg-gray-50 border rounded-lg p-4 cursor-pointer hover:bg-gray-100 transition-colors" onclick="voiceDemo.startTrainingCategory('${category}')">
                <h4 class="font-semibold capitalize">${category.replace('_', ' ')}</h4>
                <p class="text-sm text-gray-600">${terms.length} terms</p>
                <div class="mt-2">
                    <div class="text-xs text-gray-500">Sample terms:</div>
                    <div class="text-xs text-gray-700">${terms.slice(0, 3).join(', ')}${terms.length > 3 ? '...' : ''}</div>
                </div>
            </div>
        `).join('');
        
        categoriesDiv.innerHTML = categoriesHTML;
    }
    
    async startTrainingCategory(category) {
        // Implementation for training category would go here
        console.log('Starting training for category:', category);
        // This would show the training interface for the selected category
    }
    
    displayDictationInterface() {
        // Reset to dictation mode - this is already handled by the existing interface
        console.log('Switched to dictation mode');
    }'user_id', this.userId);
            formData.append('session_id', this.trainingSession.session_id);
            formData.append('term_id', this.currentTrainingTerm.id);
            formData.append('expected_term', this.currentTrainingTerm.term);
            
            const response = await fetch('/api/voice/training/record', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.displayTrainingFeedback(result);
                setTimeout(() => this.nextTrainingTerm(), 2000);
            } else {
                this.showTrainingError(result.error || 'Training failed');
            }
            
        } catch (error) {
            console.error('Training audio processing failed:', error);
            this.showTrainingError('Failed to process training audio');
        } finally {
            this.resetTrainingRecordButton();
        }
    }
    
    displayTrainingFeedback(result) {
        const feedbackDiv = document.getElementById('training-feedback');
        if (!feedbackDiv) return;
        
        feedbackDiv.classList.remove('hidden');
        
        const accuracy = result.accuracy_score || 0;
        const isGood = accuracy >= 0.8;
        
        feedbackDiv.innerHTML = `
            <div class="p-4 rounded-lg ${isGood ? 'bg-green-100 border-green-300' : 'bg-yellow-100 border-yellow-300'}">
                <div class="flex items-center mb-2">
                    <i class="fas ${isGood ? 'fa-check-circle text-green-600' : 'fa-exclamation-triangle text-yellow-600'} mr-2"></i>
                    <span class="font-semibold">${isGood ? 'Great pronunciation!' : 'Good attempt!'}</span>
                </div>
                <div class="text-sm">
                    <div>Accuracy: ${(accuracy * 100).toFixed(1)}%</div>
                    ${result.transcription ? `<div>Heard: "${result.transcription}"</div>` : ''}
                    ${result.feedback ? `<div class="mt-2">${result.feedback}</div>` : ''}
                </div>
            </div>
        `;
    }
    
    showTrainingError(message) {
        const feedbackDiv = document.getElementById('training-feedback');
        if (!feedbackDiv) return;
        
        feedbackDiv.classList.remove('hidden');
        feedbackDiv.innerHTML = `
            <div class="p-4 rounded-lg bg-red-100 border-red-300">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-circle text-red-600 mr-2"></i>
                    <span class="font-semibold text-red-800">${message}</span>
                </div>
            </div>
        `;
        
        this.resetTrainingRecordButton();
    }
    
    resetTrainingRecordButton() {
        const recordBtn = document.getElementById('training-record-btn');
        if (recordBtn) {
            recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i>Record Training';
            recordBtn.classList.remove('recording');
        }
        this.showStatus('ready', 'Ready for next term');
    }
    
    async skipTrainingTerm() {
        await this.nextTrainingTerm();
    }
    
    async nextTrainingTerm() {
        try {
            const response = await fetch('/api/voice/training/session/next', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.trainingSession.session_id,
                    user_id: this.userId
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                if (data.completed) {
                    this.completeTrainingSession();
                } else {
                    this.currentTrainingTerm = data.current_term;
                    this.trainingSession.current_index = data.current_index;
                    this.displayTrainingInterface();
                }
            }
        } catch (error) {
            console.error('Failed to get next training term:', error);
        }
    }
    
    async completeTrainingSession() {
        try {
            const response = await fetch('/api/voice/training/session/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.trainingSession.session_id,
                    user_id: this.userId
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                this.displayTrainingComplete(data.stats);
                this.trainingSession = null;
                this.currentTrainingTerm = null;
            }
        } catch (error) {
            console.error('Failed to complete training session:', error);
        }
    }
    
    displayTrainingComplete(stats) {
        if (!this.transcriptionArea) return;
        
        this.transcriptionArea.innerHTML = `
            <div class="training-complete text-center">
                <div class="mb-6">
                    <i class="fas fa-trophy text-yellow-500 text-6xl mb-4"></i>
                    <h2 class="text-3xl font-bold text-green-600 mb-2">Training Complete!</h2>
                    <p class="text-gray-600">Great job improving your medical terminology pronunciation</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="bg-blue-100 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-blue-600">${stats.terms_practiced || 0}</div>
                        <div class="text-sm text-blue-800">Terms Practiced</div>
                    </div>
                    <div class="bg-green-100 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-green-600">${(stats.average_accuracy * 100).toFixed(1)}%</div>
                        <div class="text-sm text-green-800">Average Accuracy</div>
                    </div>
                    <div class="bg-purple-100 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-purple-600">${stats.session_duration || 0}min</div>
                        <div class="text-sm text-purple-800">Session Duration</div>
                    </div>
                </div>
                
                <div class="flex justify-center space-x-4">
                    <button onclick="switchMode('training')" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg">
                        <i class="fas fa-redo mr-2"></i>Train More
                    </button>
                    <button onclick="switchMode('dictation')" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg">
                        <i class="fas fa-microphone mr-2"></i>Start Dictating
                    </button>
                </div>
            </div>
        `;
        
        // Reload training progress
        loadTrainingProgress();
    }
    
    // ============================================================================
    // VOICE SHORTCUTS FUNCTIONALITY
    // ============================================================================
    
    async loadUserShortcuts() {
        try {
            const response = await fetch(`/api/voice/shortcuts/list?user_id=${this.userId}`);
            const data = await response.json();
            
            if (data.success) {
                this.userShortcuts = data.shortcuts;
                this.displayUserShortcuts();
            }
        } catch (error) {
            console.error('Failed to load user shortcuts:', error);
        }
    }
    
    displayUserShortcuts() {
        const container = document.getElementById('shortcuts-list');
        if (!container) return;
        
        if (this.userShortcuts.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fas fa-bolt text-4xl mb-4"></i>
                    <p class="text-lg mb-2">No voice shortcuts created yet</p>
                    <p class="text-sm">Create shortcuts to quickly access report templates</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = this.userShortcuts.map(shortcut => `
            <div class="shortcut-item bg-gray-50 p-4 rounded-lg border">
                <div class="flex justify-between items-start">
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">${shortcut.shortcut_name}</h3>
                        <p class="text-gray-600 text-sm mb-2">Template: ${shortcut.template_name || 'Custom'}</p>
                        <div class="text-xs text-gray-500">
                            Created: ${new Date(shortcut.created_date).toLocaleDateString()}
                            ${shortcut.usage_count ? ` ‚Ä¢ Used ${shortcut.usage_count} times` : ''}
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="voiceDemo.testShortcut('${shortcut.id}')" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
                            <i class="fas fa-play mr-1"></i>Test
                        </button>
                        <button onclick="voiceDemo.editShortcut('${shortcut.id}')" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                            <i class="fas fa-edit mr-1"></i>Edit
                        </button>
                        <button onclick="voiceDemo.deleteShortcut('${shortcut.id}')" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">
                            <i class="fas fa-trash mr-1"></i>Delete
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    showCreateShortcutInterface() {
        if (!this.transcriptionArea) return;
        
        this.transcriptionArea.innerHTML = `
            <div class="create-shortcut-interface">
                <h2 class="text-2xl font-bold mb-6 text-center">Create Voice Shortcut</h2>
                
                <div class="space-y-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Shortcut Name</label>
                        <input type="text" id="shortcut-name" class="w-full p-3 border border-gray-300 rounded-lg" 
                               placeholder="e.g., 'Open chest X-ray template'">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Voice Command</label>
                        <div class="text-center">
                            <button id="record-shortcut-btn" class="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-semibold">
                                <i class="fas fa-microphone mr-2"></i>Record Voice Command
                            </button>
                            <p class="text-sm text-gray-500 mt-2">Record a short, clear voice command (2-5 seconds)</p>
                        </div>
                        <div id="shortcut-audio-feedback" class="mt-4 hidden"></div>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Template</label>
                        <select id="template-select" class="w-full p-3 border border-gray-300 rounded-lg">
                            <option value="">Select a template...</option>
                            <option value="chest-xray">Chest X-ray Report</option>
                            <option value="consultation">Consultation Note</option>
                            <option value="discharge">Discharge Summary</option>
                            <option value="referral">Referral Letter</option>
                            <option value="custom">Custom Template</option>
                        </select>
                    </div>
                    
                    <div id="custom-template-area" class="hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Custom Template Content</label>
                        <textarea id="custom-template" class="w-full p-3 border border-gray-300 rounded-lg h-32" 
                                  placeholder="Enter your custom template content..."></textarea>
                    </div>
                    
                    <div class="flex justify-center space-x-4">
                        <button id="save-shortcut-btn" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg" disabled>
                            <i class="fas fa-save mr-2"></i>Save Shortcut
                        </button>
                        <button onclick="switchMode('shortcuts')" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg">
                            <i class="fas fa-times mr-2"></i>Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add event listeners
        document.getElementById('record-shortcut-btn').addEventListener('click', () => this.recordShortcutCommand());
        document.getElementById('save-shortcut-btn').addEventListener('click', () => this.saveVoiceShortcut());
        document.getElementById('template-select').addEventListener('change', (e) => {
            const customArea = document.getElementById('custom-template-area');
            if (e.target.value === 'custom') {
                customArea.classList.remove('hidden');
            } else {
                customArea.classList.add('hidden');
            }
            this.validateShortcutForm();
        });
        
        document.getElementById('shortcut-name').addEventListener('input', () => this.validateShortcutForm());
    }
    
    validateShortcutForm() {
        const name = document.getElementById('shortcut-name')?.value;
        const template = document.getElementById('template-select')?.value;
        const hasAudio = this.shortcutAudioBlob !== null;
        
        const saveBtn = document.getElementById('save-shortcut-btn');
        if (saveBtn) {
            saveBtn.disabled = !name || !template || !hasAudio;
        }
    }
    
    async recordShortcutCommand() {
        if (this.isRecording) {
            await this.stopShortcutRecording();
        } else {
            await this.startShortcutRecording();
        }
    }
    
    async startShortcutRecording() {
        try {
            this.isRecording = true;
            this.shortcutAudioBlob = null;
            
            const recordBtn = document.getElementById('record-shortcut-btn');
            if (recordBtn) {
                recordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Recording';
                recordBtn.classList.add('recording');
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            this.audioChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = () => {
                this.processShortcutAudio();
            };
            
            this.mediaRecorder.start();
            
            // Auto-stop after 5 seconds
            setTimeout(() => {
                if (this.isRecording) {
                    this.stopShortcutRecording();
                }
            }, 5000);
            
        } catch (error) {
            console.error('Shortcut recording error:', error);
            this.isRecording = false;
        }
    }
    
    async stopShortcutRecording() {
        if (!this.isRecording) return;
        
        this.isRecording = false;
        
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
        
        if (this.mediaRecorder && this.mediaRecorder.stream) {
            this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }
    
    async processShortcutAudio() {
        try {
            this.shortcutAudioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            
            const feedbackDiv = document.getElementById('shortcut-audio-feedback');
            if (feedbackDiv) {
                feedbackDiv.classList.remove('hidden');
                feedbackDiv.innerHTML = `
                    <div class="bg-green-100 p-3 rounded-lg border-green-300">
                        <i class="fas fa-check-circle text-green-600 mr-2"></i>
                        Voice command recorded successfully
                    </div>
                `;
            }
            
            const recordBtn = document.getElementById('record-shortcut-btn');
            if (recordBtn) {
                recordBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Re-record Command';
                recordBtn.classList.remove('recording');
            }
            
            this.validateShortcutForm();
            
        } catch (error) {
            console.error('Shortcut audio processing failed:', error);
        }
    }
    
    async saveVoiceShortcut() {
        try {
            const name = document.getElementById('shortcut-name').value;
            const templateType = document.getElementById('template-select').value;
            const customTemplate = document.getElementById('custom-template')?.value;
            
            if (!this.shortcutAudioBlob) {
                alert('Please record a voice command first');
                return;
            }
            
            const formData = new FormData();
            formData.append('audio', this.shortcutAudioBlob, 'shortcut_command.wav');
            formData.append('user_id', this.userId);
            formData.append('shortcut_name', name);
            formData.append('template_type', templateType);
            if (customTemplate) {
                formData.append('template_content', customTemplate);
            }
            
            const response = await fetch('/api/voice/shortcuts/create', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Show success message and return to shortcuts list
                alert('Voice shortcut created successfully!');
                switchMode('shortcuts');
                this.loadUserShortcuts();
            } else {
                alert('Failed to create shortcut: ' + (result.error || 'Unknown error'));
            }
            
        } catch (error) {
            console.error('Failed to save voice shortcut:', error);
            alert('Failed to save voice shortcut');
        }
    }
    
    async checkForVoiceShortcuts(audioBlob) {
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'shortcut_check.wav');
            formData.append('user_id', this.userId);
            
            const response = await fetch('/api/voice/shortcuts/match', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success && result.matched) {
                // Load the matched template
                this.loadTemplate(result.shortcut.template_type, result.shortcut.template_content);
                
                // Show feedback
                this.showStatus('ready', `Loaded template: ${result.shortcut.shortcut_name}`);
                return true;
            }
            
            return false;
            
        } catch (error) {
            console.error('Voice shortcut matching failed:', error);
            return false;
        }
    }
    
    loadTemplate(templateType, customContent = null) {
        const templates = {
            'chest-xray': 'CHEST X-RAY REPORT\n\nPatient: [Patient Name]\nDate: [Date]\n\nFINDINGS:\nThe chest X-ray shows:\n\nIMPRESSION:\n\nRecommendations:\n',
            'consultation': 'CONSULTATION NOTE\n\nChief Complaint:\n\nHistory of Present Illness:\n\nPhysical Examination:\n\nAssessment and Plan:\n',
            'discharge': 'DISCHARGE SUMMARY\n\nAdmission Date:\nDischarge Date:\n\nDiagnoses:\n\nHospital Course:\n\nDischarge Medications:\n\nFollow-up Instructions:\n',
            'referral': 'REFERRAL LETTER\n\nTo: [Specialist/Department]\nFrom: [Your Name]\n\nReason for Referral:\n\nClinical History:\n\nExamination Findings:\n\nInvestigations:\n\nThank you for seeing this patient.\n'
        };
        
        const template = customContent || templates[templateType] || '';
        this.transcriptionText = template;
        
        if (this.transcriptionArea) {
            this.transcriptionArea.innerHTML = `<div class="text-gray-800 whitespace-pre-line">${template}</div>`;
            this.transcriptionArea.classList.add('active');
        }
        
        const textarea = document.getElementById('report-text');
        if (textarea) {
            textarea.value = template;
        }
    }
    
    displayDictationInterface() {
        // Reset to default dictation interface
        if (this.transcriptionArea && !this.transcriptionText) {
            this.transcriptionArea.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fas fa-microphone text-4xl mb-4"></i>
                    <p>Click the microphone button to start dictating</p>
                    <p class="text-sm mt-2">Voice shortcuts and medical training are active</p>
                </div>
            `;
        }
    }
}

// Export for global access
window.SAVoiceDemo = SAVoiceDemo; 
   // ============================================================================
    // MEDICAL TRAINING FUNCTIONALITY
    // ============================================================================
    
    async loadTrainingCategories() {
        try {
            const response = await fetch(`/api/voice/training/categories?user_id=${this.userId}`);
            const data = await response.json();
            
            if (data.success) {
                this.displayTrainingCategories(data.categories);
            }
        } catch (error) {
            console.error('Failed to load training categories:', error);
        }
    }
    
    displayTrainingCategories(categories) {
        const container = document.getElementById('training-categories');
        if (!container) return;
        
        container.innerHTML = '';
        
        Object.keys(categories).forEach(category => {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'training-category bg-white p-4 rounded-lg shadow-sm border hover:shadow-md transition-shadow cursor-pointer';
            categoryDiv.innerHTML = `
                <h3 class="font-semibold text-lg mb-2 capitalize">${category.replace('_', ' ')}</h3>
                <p class="text-gray-600 text-sm mb-3">${categories[category].length} terms</p>
                <button class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors">
                    Start Training
                </button>
            `;
            
            categoryDiv.addEventListener('click', () => this.startTrainingSession(category));
            container.appendChild(categoryDiv);
        });
    }
    
    async startTrainingSession(category) {
        try {
            this.currentMode = 'training';
            this.showStatus('processing', 'Starting training session...');
            
            const response = await fetch('/api/voice/training/session/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: this.userId,
                    category: category
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                this.trainingSession = data;
                this.currentTrainingTerm = data.current_term;
                this.displayTrainingInterface();
                this.showStatus('ready', `Training: ${category} (${data.total_terms} terms)`);
            }
        } catch (error) {
            console.error('Failed to start training session:', error);
            this.showStatus('error', 'Failed to start training session');
        }
    }
    
    displayTrainingInterface() {
        if (!this.transcriptionArea) return;
        
        const term = this.currentTrainingTerm;
        if (!term) return;
        
        this.transcriptionArea.innerHTML = `
            <div class="training-interface">
                <div class="text-center mb-6">
                    <h3 class="text-2xl font-bold mb-4">Training: ${term.term}</h3>
                    <p class="text-gray-600 mb-2">Category: ${term.category}</p>
                    <p class="text-sm text-gray-500 mb-4">Read the term clearly and naturally</p>
                    
                    <div class="bg-blue-50 p-4 rounded-lg mb-6">
                        <div class="text-3xl font-bold text-blue-800 mb-2">${term.term}</div>
                        ${term.pronunciation_guide ? `<div class="text-sm text-blue-600">Pronunciation: ${term.pronunciation_guide}</div>` : ''}
                        ${term.definition ? `<div class="text-sm text-gray-600 mt-2">${term.definition}</div>` : ''}
                    </div>
                    
                    <div class="flex justify-center space-x-4">
                        <button id="training-record-btn" class="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-semibold">
                            <i class="fas fa-microphone mr-2"></i>Record Training
                        </button>
                        <button id="training-skip-btn" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg">
                            <i class="fas fa-forward mr-2"></i>Skip Term
                        </button>
                        <button id="training-complete-btn" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg">
                            <i class="fas fa-check mr-2"></i>Complete Session
                        </button>
                    </div>
                    
                    <div id="training-feedback" class="mt-4 hidden">
                        <!-- Training feedback will appear here -->
                    </div>
                    
                    <div class="mt-6 text-sm text-gray-500">
                        Progress: ${this.trainingSession.current_index + 1} of ${this.trainingSession.total_terms} terms
                        <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                            <div class="bg-blue-600 h-2 rounded-full" style="width: ${((this.trainingSession.current_index + 1) / this.trainingSession.total_terms) * 100}%"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add event listeners for training buttons
        document.getElementById('training-record-btn').addEventListener('click', () => this.recordTrainingAudio());
        document.getElementById('training-skip-btn').addEventListener('click', () => this.skipTrainingTerm());
        document.getElementById('training-complete-btn').addEventListener('click', () => this.completeTrainingSession());
                    <h2 class="text-2xl font-bold mb-2">Medical Terminology Training</h2>
                    <div class="bg-blue-100 p-4 rounded-lg mb-4">
                        <h3 class="text-lg font-semibold mb-2">Current Term:</h3>
                        <p class="text-2xl font-bold text-blue-800" id="current-training-term">${this.currentTrainingTerm}</p>
                    </div>
                    <p class="text-gray-600 mb-4">Read the term aloud clearly when you press record</p>
                    
                    <div class="flex justify-center gap-4 mb-4">
                        <button id="record-training-btn" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-colors">
                            <i class="fas fa-microphone mr-2"></i>Record Term
                        </button>
                        <button id="skip-term-btn" class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors">
                            Skip Term
                        </button>
                        <button id="exit-training-btn" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors">
                            Exit Training
                        </button>
                    </div>
                    
                    <div id="training-feedback" class="mt-4"></div>
                    
                    <div class="mt-6 bg-gray-100 p-4 rounded-lg">
                        <h4 class="font-semibold mb-2">Progress</h4>
                        <div class="w-full bg-gray-300 rounded-full h-2">
                            <div id="training-progress-bar" class="bg-blue-600 h-2 rounded-full" style="width: 0%"></div>
                        </div>
                        <p class="text-sm text-gray-600 mt-2" id="training-progress-text">0 / ${this.trainingSession?.total_terms || 0} terms completed</p>
                    </div>
                </div>
            </div>
        `;
        
        // Setup training event listeners
        document.getElementById('record-training-btn')?.addEventListener('click', () => this.recordTrainingTerm());
        document.getElementById('skip-term-btn')?.addEventListener('click', () => this.skipTrainingTerm());
        document.getElementById('exit-training-btn')?.addEventListener('click', () => this.exitTraining());
    }
    
    async recordTrainingTerm() {
        if (!this.currentTrainingTerm) return;
        
        try {
            this.showStatus('listening', 'Recording training audio...');
            
            // Start recording
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            const audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await this.processTrainingAudio(audioBlob);
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            
            // Record for 3 seconds
            setTimeout(() => {
                mediaRecorder.stop();
            }, 3000);
            
        } catch (error) {
            console.error('Training recording failed:', error);
            this.showStatus('error', 'Recording failed');
        }
    }
    
    async processTrainingAudio(audioBlob) {
        try {
            this.showStatus('processing', 'Processing training audio...');
            
            const formData = new FormData();
            formData.append('audio', audioBlob);
            formData.append('session_id', this.trainingSession.session_id);
            formData.append('expected_term', this.currentTrainingTerm);
            formData.append('user_id', this.userId);
            
            const response = await fetch('/api/voice/training/record', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.displayTrainingFeedback(result);
                
                if (result.next_term) {
                    this.currentTrainingTerm = result.next_term;
                    document.getElementById('current-training-term').textContent = result.next_term;
                } else {
                    this.completeTrainingSession();
                }
                
                // Update progress
                if (result.progress) {
                    const progressBar = document.getElementById('training-progress-bar');
                    const progressText = document.getElementById('training-progress-text');
                    
                    if (progressBar) {
                        progressBar.style.width = `${result.progress.percentage}%`;
                    }
                    if (progressText) {
                        progressText.textContent = `${result.progress.completed} / ${result.progress.total} terms completed`;
                    }
                }
                
                this.showStatus('ready', 'Ready for next term');
            } else {
                this.showStatus('error', 'Training processing failed');
            }
            
        } catch (error) {
            console.error('Training audio processing failed:', error);
            this.showStatus('error', 'Processing failed');
        }
    }
    
    displayTrainingFeedback(result) {
        const feedbackDiv = document.getElementById('training-feedback');
        if (!feedbackDiv) return;
        
        const accuracy = (result.accuracy_score * 100).toFixed(1);
        const isGood = result.accuracy_score >= 0.7;
        
        feedbackDiv.innerHTML = `
            <div class="p-4 rounded-lg ${isGood ? 'bg-green-100 border-green-300' : 'bg-yellow-100 border-yellow-300'} border">
                <div class="flex items-center mb-2">
                    <i class="fas ${isGood ? 'fa-check-circle text-green-600' : 'fa-exclamation-triangle text-yellow-600'} mr-2"></i>
                    <span class="font-semibold">${isGood ? 'Good pronunciation!' : 'Needs improvement'}</span>
                </div>
                <p class="text-sm">Accuracy: ${accuracy}%</p>
                <p class="text-sm">Expected: "${result.expected}"</p>
                <p class="text-sm">Heard: "${result.actual}"</p>
                ${result.needs_retry ? '<p class="text-sm text-yellow-700 mt-2">Consider practicing this term again</p>' : ''}
            </div>
        `;
    }
    
    skipTrainingTerm() {
        // Move to next term without recording
        // Implementation would call API to get next term
        console.log('Skipping term:', this.currentTrainingTerm);
    }
    
    exitTraining() {
        this.currentMode = 'dictation';
        this.trainingSession = null;
        this.currentTrainingTerm = null;
        this.displayDictationInterface();
        this.showStatus('ready', 'Returned to dictation mode');
    }
    
    completeTrainingSession() {
        const feedbackDiv = document.getElementById('training-feedback');
        if (feedbackDiv) {
            feedbackDiv.innerHTML = `
                <div class="p-4 rounded-lg bg-green-100 border-green-300 border text-center">
                    <i class="fas fa-trophy text-green-600 text-3xl mb-2"></i>
                    <h3 class="font-semibold text-lg mb-2">Training Complete!</h3>
                    <p class="text-sm mb-4">Great job completing the training session.</p>
                    <button onclick="voiceDemo.exitTraining()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                        Return to Dictation
                    </button>
                </div>
            `;
        }
    }
    
    // ============================================================================
    // VOICE SHORTCUTS FUNCTIONALITY
    // ============================================================================
    
    async loadUserShortcuts() {
        try {
            const response = await fetch(`/api/voice/shortcuts?user_id=${this.userId}`);
            const data = await response.json();
            
            if (data.success) {
                this.userShortcuts = data.shortcuts;
                this.displayShortcutsList();
            }
        } catch (error) {
            console.error('Failed to load shortcuts:', error);
        }
    }
    
    displayShortcutsList() {
        const container = document.getElementById('shortcuts-list');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (this.userShortcuts.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fas fa-microphone-alt text-4xl mb-4"></i>
                    <p>No voice shortcuts created yet</p>
                    <button onclick="voiceDemo.showCreateShortcutInterface()" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                        Create First Shortcut
                    </button>
                </div>
            `;
            return;
        }
        
        this.userShortcuts.forEach(shortcut => {
            const shortcutDiv = document.createElement('div');
            shortcutDiv.className = 'shortcut-item bg-white p-4 rounded-lg shadow-sm border hover:shadow-md transition-shadow';
            shortcutDiv.innerHTML = `
                <div class="flex justify-between items-start">
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">${shortcut.name}</h3>
                        <p class="text-gray-600 text-sm">Used ${shortcut.usage_count} times</p>
                        <p class="text-gray-500 text-xs">Accuracy: ${(shortcut.accuracy_score * 100).toFixed(1)}%</p>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="voiceDemo.testShortcut(${shortcut.id})" class="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700">
                            Test
                        </button>
                        <button onclick="voiceDemo.editShortcut(${shortcut.id})" class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700">
                            Edit
                        </button>
                        <button onclick="voiceDemo.deleteShortcut(${shortcut.id})" class="bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700">
                            Delete
                        </button>
                    </div>
                </div>
                ${shortcut.template_content ? `<div class="mt-2 p-2 bg-gray-100 rounded text-sm">${shortcut.template_content.substring(0, 100)}...</div>` : ''}
            `;
            container.appendChild(shortcutDiv);
        });
    }
    
    showCreateShortcutInterface() {
        this.currentMode = 'shortcut_creation';
        
        if (this.transcriptionArea) {
            this.transcriptionArea.innerHTML = `
                <div class="shortcut-creation-interface">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold mb-4">Create Voice Shortcut</h2>
                        
                        <div class="bg-blue-100 p-4 rounded-lg mb-4">
                            <label class="block text-sm font-semibold mb-2">Shortcut Name:</label>
                            <input type="text" id="shortcut-name" class="w-full p-2 border rounded" placeholder="e.g., 'Open chest X-ray template'">
                        </div>
                        
                        <div class="bg-blue-100 p-4 rounded-lg mb-4">
                            <label class="block text-sm font-semibold mb-2">Template Content (optional):</label>
                            <textarea id="shortcut-template" class="w-full p-2 border rounded h-24" placeholder="Template content to load when shortcut is triggered..."></textarea>
                        </div>
                        
                        <div class="flex justify-center gap-4 mb-4">
                            <button id="record-shortcut-btn" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-colors">
                                <i class="fas fa-microphone mr-2"></i>Record Voice Command
                            </button>
                            <button id="cancel-shortcut-btn" class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors">
                                Cancel
                            </button>
                        </div>
                        
                        <div id="shortcut-feedback" class="mt-4"></div>
                    </div>
                </div>
            `;
        }
        
        document.getElementById('record-shortcut-btn')?.addEventListener('click', () => this.recordShortcutCommand());
        document.getElementById('cancel-shortcut-btn')?.addEventListener('click', () => this.exitShortcutCreation());
    }
    
    async recordShortcutCommand() {
        const nameInput = document.getElementById('shortcut-name');
        const templateInput = document.getElementById('shortcut-template');
        
        if (!nameInput?.value.trim()) {
            alert('Please enter a shortcut name');
            return;
        }
        
        try {
            this.showStatus('listening', 'Recording voice command...');
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            const audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await this.createVoiceShortcut(audioBlob, nameInput.value.trim(), templateInput?.value.trim());
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            
            // Record for 3 seconds
            setTimeout(() => {
                mediaRecorder.stop();
            }, 3000);
            
        } catch (error) {
            console.error('Shortcut recording failed:', error);
            this.showStatus('error', 'Recording failed');
        }
    }
    
    async createVoiceShortcut(audioBlob, name, templateContent) {
        try {
            this.showStatus('processing', 'Creating voice shortcut...');
            
            const formData = new FormData();
            formData.append('audio', audioBlob);
            formData.append('name', name);
            formData.append('user_id', this.userId);
            if (templateContent) {
                formData.append('template_content', templateContent);
            }
            
            const response = await fetch('/api/voice/shortcuts/create', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                const feedbackDiv = document.getElementById('shortcut-feedback');
                if (feedbackDiv) {
                    feedbackDiv.innerHTML = `
                        <div class="p-4 rounded-lg bg-green-100 border-green-300 border">
                            <i class="fas fa-check-circle text-green-600 mr-2"></i>
                            <span class="font-semibold">Voice shortcut created successfully!</span>
                            <div class="mt-2">
                                <button onclick="voiceDemo.exitShortcutCreation()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mr-2">
                                    Done
                                </button>
                                <button onclick="voiceDemo.showCreateShortcutInterface()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
                                    Create Another
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                // Reload shortcuts list
                await this.loadUserShortcuts();
                this.showStatus('ready', 'Shortcut created successfully');
            } else {
                this.showStatus('error', 'Failed to create shortcut');
            }
            
        } catch (error) {
            console.error('Shortcut creation failed:', error);
            this.showStatus('error', 'Creation failed');
        }
    }
    
    exitShortcutCreation() {
        this.currentMode = 'dictation';
        this.displayDictationInterface();
        this.showStatus('ready', 'Returned to dictation mode');
    }
    
    displayDictationInterface() {
        if (this.transcriptionArea) {
            this.transcriptionArea.innerHTML = `
                <div class="dictation-interface">
                    <div class="text-center text-gray-500 py-8">
                        <i class="fas fa-microphone text-4xl mb-4"></i>
                        <p>Click the microphone button to start dictating</p>
                        <p class="text-sm mt-2">Voice shortcuts and medical training are active</p>
                    </div>
                </div>
            `;
        }
    }
    
    async checkForVoiceShortcuts(audioBlob) {
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob);
            formData.append('user_id', this.userId);
            formData.append('confidence_threshold', '0.7');
            
            const response = await fetch('/api/voice/shortcuts/match', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success && result.match_found) {
                this.executeShortcut(result.shortcut, result.template_content);
                return true; // Shortcut was triggered
            }
            
            return false; // No shortcut matched
            
        } catch (error) {
            console.error('Shortcut matching failed:', error);
            return false;
        }
    }
    
    executeShortcut(shortcut, templateContent) {
        console.log('Executing shortcut:', shortcut.name);
        
        if (templateContent && this.transcriptionArea) {
            // Load template content
            this.transcriptionText = templateContent;
            this.transcriptionArea.innerHTML = `
                <div class="template-loaded">
                    <div class="bg-blue-100 p-2 rounded mb-2 text-sm">
                        <i class="fas fa-magic mr-2"></i>Loaded template: ${shortcut.name}
                    </div>
                    <div class="transcription-content">${templateContent}</div>
                </div>
            `;
        }
        
        this.showStatus('ready', `Shortcut activated: ${shortcut.name}`);
    }
    
    async testShortcut(shortcutId) {
        console.log('Testing shortcut:', shortcutId);
        // Implementation for testing a shortcut
    }
    
    async editShortcut(shortcutId) {
        console.log('Editing shortcut:', shortcutId);
        // Implementation for editing a shortcut
    }
    
    async deleteShortcut(shortcutId) {
        if (confirm('Are you sure you want to delete this shortcut?')) {
            try {
                const response = await fetch(`/api/voice/shortcuts/${shortcutId}?user_id=${this.userId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await this.loadUserShortcuts();
                    this.showStatus('ready', 'Shortcut deleted');
                }
            } catch (error) {
                console.error('Failed to delete shortcut:', error);
            }
        }
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('üáøüá¶ Initializing SA Medical Voice Demo...');
    
    // Check for HTTPS
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        console.warn('‚ö†Ô∏è HTTPS required for microphone access');
        return;
    }
    
    // Initialize voice demo
    try {
        window.saVoiceDemo = new SAVoiceDemo();
        console.log('‚úÖ SA Medical Voice Demo initialized successfully');
    } catch (error) {
        console.error('‚ùå Failed to initialize voice demo:', error);
    }
});